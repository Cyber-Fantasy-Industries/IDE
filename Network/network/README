# GatewayIDE â€“ Secure Network Milestone

## WireGuard â†’ Nebula

### Status

ðŸŸ¡ In Planung / Architekturphase
Dieser Meilenstein definiert die Netzwerk- und Sicherheitsbasis fÃ¼r GatewayIDE und das spÃ¤tere **Cyber Fantasy World Network**.

---

## Ziel des Meilensteins

Ziel ist der Aufbau eines **gesicherten Multi-User-Netzwerks**, in dem:

* Clients sich **vor dem Start jeglicher Engines** mit einem zentralen GatewayIDE-Server verbinden
* Authentifizierung, Rechte und Sitzungen **zwingend vorgeschaltet** sind
* Engines **niemals direkt exponiert** werden
* ein sicheres Heim- / Firmennetz mit **statischer IP** als Anker dient
* externe Nutzer kontrolliert Teil des Netzwerks werden kÃ¶nnen

Dieser Meilenstein legt **keine UI**, **keine Engines** und **keine Agentenlogik** fest â€“
er schafft ausschlieÃŸlich die **Netzwerk- und Sicherheitsgrundlage**.

---

## Backend-Fokus dieses Meilensteins

Der Schwerpunkt liegt explizit auf dem **Backend**.

* Netzwerklogik liegt unter `backend/network/`
* Ã–ffentliche und interne API-Schnittstellen liegen unter `backend/routes/`
* Das Backend fungiert als **Control Plane** zwischen Netzwerk, Authentifizierung und Engines

Die IDE selbst ist in diesem Meilenstein lediglich ein Client des Backends.

---

## Architektur-Prinzipien

### 1. Control Plane vor Execution

Kein Engine-Start, kein Projektzugriff, keine Runtime-Aktion ohne:

* gÃ¼ltige Netzwerkverbindung
* authentifizierten Nutzer
* serverseitige Entscheidung

### 2. Zero Trust innerhalb des Netzes

* Kein implizites Vertrauen aufgrund von IP, Standort oder Port
* Jeder Zugriff ist:

  * authentifiziert
  * autorisiert
  * protokolliert

### 3. Trennung der Ebenen

* **Netzwerk** â‰  **Auth** â‰  **Engines**
* Clients sprechen **nie direkt** mit Engines
* Alles lÃ¤uft Ã¼ber die GatewayIDE-Control-Plane

---

## Phase 1: WireGuard (Baseline)

WireGuard bildet die **erste stabile Netzwerkbasis**.

### Warum WireGuard zuerst?

* Minimalistisch, auditierbar, performant
* VollstÃ¤ndig self-hosted
* Ideal fÃ¼r:

  * statische IPs
  * Heim- / Firmennetze
  * kontrollierte Peer-ZugÃ¤nge

### Rolle von WireGuard im Backend

WireGuard selbst ist **kein Teil der Business-Logik**, wird jedoch durch das Backend **verwaltet und kontrolliert**:

* Peer-Erstellung erfolgt serverseitig
* SchlÃ¼sselmaterial wird nie unkontrolliert verteilt
* Peers sind immer einem Nutzer **und** einem GerÃ¤t zugeordnet

Das Backend entscheidet:

* **wer** einen Peer bekommt
* **wann** ein Peer aktiv ist
* **welche Subnetze** erreichbar sind

### Eigenschaften

* Jeder Client = eigener Peer
* Eigene Keypaare pro Nutzer / GerÃ¤t
* Netzwerksegmentierung Ã¼ber AllowedIPs
* GatewayIDE-Server als zentraler Hub (Hub-and-Spoke)

### Erwartete Struktur (Beispiel)

```
CyberFantasyNet (WireGuard)
â”œâ”€â”€ GatewayIDE Server        (10.77.0.10)
â”œâ”€â”€ Admin / Owner Clients    (10.77.0.20â€“29)
â”œâ”€â”€ Developer Clients        (10.77.0.30â€“99)
â””â”€â”€ Service Subnets          (nicht direkt erreichbar)
```

Engines und interne Services liegen **auÃŸerhalb** des Client-Subnetzes.

---

## Backend-Verzeichnisstruktur (geplant)

```
backend/
â”œâ”€â”€ network/
â”‚   â”œâ”€â”€ README.txt          # Netzwerkarchitektur & Konzepte
â”‚   â”œâ”€â”€ wireguard.py        # Peer- & Config-Management
â”‚   â”œâ”€â”€ nebula.py           # spÃ¤ter: Nebula-Integration
â”‚   â””â”€â”€ models.py           # Network / Peer / Device Modelle
â”‚
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ network.py          # API: Netzwerkstatus, Enrollment
â”‚   â”œâ”€â”€ devices.py          # GerÃ¤te-Registrierung
â”‚   â””â”€â”€ admin_network.py    # Admin-only Netzwerkoperationen
```

---

## API-Rollen im Netzwerk-Kontext

### Ã–ffentliche (authentifizierte) Routen

* Netzwerkstatus des Clients
* Eigene Peer-Informationen
* Verbindungs- & Health-Checks

### Interne / Admin-Routen

* Peer-Erstellung / Deaktivierung
* AllowedIPs-Ã„nderungen
* GerÃ¤te-Sperrung
* Audit-Abfragen

Alle Netzwerk-relevanten Routen sind **nicht Ã¶ffentlich exponiert**, sondern:

* nur Ã¼ber VPN erreichbar
* zusÃ¤tzlich durch Auth & RBAC geschÃ¼tzt

---

## Phase 2: Nebula (Skalierung & World Network)

Nach Stabilisierung von WireGuard folgt **Nebula** als zweite Ebene.

### Warum Nebula spÃ¤ter?

* Eigene PKI
* Sehr feingranulare ACLs
* Ideal fÃ¼r:

  * grÃ¶ÃŸere, verteilte Netze
  * wechselnde Standorte
  * â€žWorld Networkâ€œ-Topologie

### Rolle von Nebula im Backend

* Kryptografische IdentitÃ¤ten statt IP-Fokus
* Policy-gesteuerte Kommunikation zwischen Nodes
* FÃ¶derationsfÃ¤higkeit fÃ¼r spÃ¤tere Standorte

WireGuard bleibt dabei:

* als Fallback
* als lokales Backbone
* als Admin-Zugangsnetz

---

## Sicherheitsziele dieses Meilensteins

âœ” Keine offenen Engine-Ports
âœ” Keine direkten Client â†’ Engine Verbindungen
âœ” Keine Klartext-Kommunikation
âœ” Abschaltbare, rotierbare ZugÃ¤nge
âœ” Trennung von Nutzer-, GerÃ¤te- und NetzwerkidentitÃ¤t

---

## Nicht Teil dieses Meilensteins

âœ– UI / IDE-Design
âœ– Agenten / KI-Logik
âœ– Engine-Implementierungen
âœ– Projekt- oder Workspace-Management

Diese Themen bauen **spÃ¤ter** auf dieser Basis auf.

---

## Ausblick (nÃ¤chste Meilensteine)

* Authentifizierung & RBAC (OIDC / Sessions)
* Device Enrollment & Trust
* Engine Control via Capability Tokens
* Audit- & Security-Logging
* Ãœbergang WireGuard â†’ Nebula Federation

---

## Leitgedanke

> **Execution folgt Vertrauen.
> Vertrauen folgt Kontrolle.
> Kontrolle folgt Struktur.**

Dieser Meilenstein schafft die Struktur.
